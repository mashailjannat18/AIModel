# -*- coding: utf-8 -*-
"""WorkoutPlanWithRepsAndRest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QkS8_9qGAOruhASm9VaIcnnCj-C7-iYQ

In this code:
**Main Work:**
1. The workout number and durations for particular days for specific users are being calculated. The durations for individual workouts as well as for a day as a whole are being displayed in the 'final_populated_workouts.json' file.
2. The total number of calories burnt by individual workouts will be displayed against each workout aas well as the total calories burnt in one day will be displayed against the DAY value in the JSON file.

**Additional Tweaks**
1. An input function block has been defined in the start of the code that globalizes the user's input. An additional input of user's weight will be required by the database to calculate calories burnt. I have kept the data type of user weight an integer.
2. This code uses the combined logic of all the previous models like it was being done in the last file of "populateWeeklyPlansWithUserSpecificWorkouts.ipynb".

**Instrctions for Gujjar**
You probably know all this but:
1. Make sure the workouts csv dataset is loaded when you run this file
2. Kindly run it in the order it is given and keep storing the outputs in the same directories so that they can be worked on iteratively.
"""

import pandas as pd
import json

# User input declaration and conversion functions for user inputs

# Global user variables (initialized to None)
USER_AGE = None
USER_AGE_GROUP = None
USER_ACTIVITY_LEVEL = None
USER_REST_DAY = None
USER_PROGRAM_DURATION = None
USER_GOAL = None
USER_WEIGHT = None

def map_age_to_group(age):
    if age < 40:
        return 'adult'
    elif 40 <= age < 60:
        return 'middle_aged'
    else:
        return 'older_adult'

def convert_activity_level(slider_value):
  #Assumptions for activity levels
  # 0 - 34 slider : low activity
  # 35 - 69 slider : moderate activity
  # 70 - 100 slider : high activity
    if slider_value < 35:
        return 'low'
    elif slider_value < 70:
        return 'moderate'
    else:
        return 'high'

def load_user_profile():
    global USER_AGE, USER_AGE_GROUP, USER_ACTIVITY_LEVEL, USER_REST_DAY, USER_PROGRAM_DURATION, USER_GOAL, USER_WEIGHT

    # Simulated inputs from frontend (hardcoded for now)
    USER_AGE = 60
    activity_slider_value = 30  # integer slider value from 0 - 100
    USER_ACTIVITY_LEVEL = convert_activity_level(activity_slider_value)  # Converted to 'low', 'moderate', or 'high'
    USER_REST_DAY = 'Friday'
    USER_PROGRAM_DURATION = 30
    USER_GOAL = 'weight_loss'
    USER_WEIGHT = 80 # in kgs

    # Map age to age group for downstream rules
    USER_AGE_GROUP = map_age_to_group(USER_AGE)

    print({
        "Age": USER_AGE,
        "Age Group": USER_AGE_GROUP,
        "Activity Level (Slider)": activity_slider_value,
        "Converted Activity Level": USER_ACTIVITY_LEVEL,
        "Preferred Rest Day": USER_REST_DAY,
        "Program Duration": USER_PROGRAM_DURATION,
        "Goal": USER_GOAL,
        "Weight": USER_WEIGHT
    })

# Test print
load_user_profile()

# Load and clean workout dataset
df = pd.read_csv("workouts.csv")
df['Difficulty'] = df['Difficulty'].str.strip().str.lower().str.capitalize()

# MET range thresholds
MET_RANGES = {
    'low': (1.5, 3.9),
    'moderate': (4.0, 6.9),
    'high': (7.0, 12.3)
}

# Rule-based MET recommendations
def get_recommended_met(age, activity):
    activity = activity.lower()
    if 15 <= age <= 34:
        if activity == 'low':
            return ['low']
        elif activity == 'moderate':
            return ['low', 'moderate']
        elif activity == 'high':
            return ['low', 'moderate', 'high']
    elif 35 <= age <= 49:
        if activity != 'high':
            return ['low']
        else:
            return ['low', 'moderate']
    elif age >= 50:
        if activity != 'high':
            return ['low']
        else:
            return ['low', 'moderate']
    return []

# Rule-based difficulty recommendations
def get_recommended_difficulty(age, activity):
    activity = activity.lower()
    if 15 <= age <= 34:
        return ['Beginner', 'Intermediate']
    elif 35 <= age <= 49:
        if activity in ['moderate', 'high']:
            return ['Beginner', 'Intermediate']
        else:
            return ['Beginner']
    elif age >= 50:
        return ['Beginner']
    return []

# Filtering logic
def filter_workouts(df, met_recs, diff_recs):
    met_mask = pd.Series([False] * len(df))
    for met_level in met_recs:
        if met_level in MET_RANGES:
            min_val, max_val = MET_RANGES[met_level]
            met_mask |= df['MET Value'].between(min_val, max_val)
    filtered_df = df[met_mask & df['Difficulty'].isin(diff_recs)]
    return filtered_df


def main():

    met_recs = get_recommended_met(USER_AGE, USER_ACTIVITY_LEVEL)
    diff_recs = get_recommended_difficulty(USER_AGE, USER_ACTIVITY_LEVEL)

    print("Recommended MET Levels:", met_recs)
    print("Recommended Difficulties:", diff_recs)

    personalized_df = filter_workouts(df, met_recs, diff_recs)

    if not personalized_df.empty:
        print("\n Personalized Workout Recommendations:\n")
        print(personalized_df)
    else:
        print("\n No workouts match the given filters.")

    personalized_df.to_csv("filtered_workouts.csv", index=False)
    print("Filtered workouts saved as 'filtered_workouts.csv'.")

# Run it
main()

#Generating a weekly plan with rest days
#!!It is not a populated plan just a blue print for the populated plan to work on!!

# constants
DAYS_OF_WEEK = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
GOAL_FOCUS_TEMPLATES = {
    'stay_fit': [
        'Upper Body Strength', 'Lower Body Strength','Light Endurance', 'Core + Abs',
        'Light Endurance'
    ],
    'gain_weight': [
        'Upper Body Strength', 'Core + Chest', 'Lower Body Strength',
        'Light Endurance', 'Full Body Strength'
    ],
    'weight_loss': [
        'Cardio', 'Full Body HIIT', 'Core + Lower Body',
        'Full Body HIIT', 'Abs + Upper Body'
    ],
    'build_muscle': [
        'Upper Body Strength', 'Lower Body Strength', 'Upper Body Strength',
        'Core + Abs', 'Cardio'
    ]
}

# Cleaners
def get_weekday(day_index):
    return DAYS_OF_WEEK[day_index % 7]

def get_next_focus(template_list, day_number):
    return template_list[day_number % len(template_list)]

#Main plan generation
def generate_plan(goal, program_duration, preferred_rest_day):
    plan = []
    focus_template = GOAL_FOCUS_TEMPLATES[goal]
    focus_day_counter = 0
    workout_streak = 0  # Count how many workout days since last rest

    for i in range(program_duration):
        weekday = get_weekday(i)

        if weekday == preferred_rest_day:
            focus = 'Complete Rest Day'
            workout_streak = 0  # reset streak after rest
        elif workout_streak >= 3:
            focus = 'Active Rest Day'
            workout_streak = 0
        else:
            focus = get_next_focus(focus_template, focus_day_counter)
            focus_day_counter += 1
            workout_streak += 1

        plan.append({
            'Day': f'Day {i+1} ({weekday})',
            'Focus': focus
        })

    return plan

def print_plan(plan):
    for entry in plan:
        print(entry)

def export_to_csv(plan, filename='weekly_plan_with_focus.csv'):
    pd.DataFrame(plan).to_csv(filename, index=False)

weekly_plan = generate_plan(USER_GOAL, USER_PROGRAM_DURATION, USER_REST_DAY)
print_plan(weekly_plan)
export_to_csv(weekly_plan)

#Final populated plan with rest,  reps, sets and active rest days exercises
#Different reps and duration for hold exercises

age_group = USER_AGE_GROUP
activity_level = USER_ACTIVITY_LEVEL
goal = USER_GOAL
weight = USER_WEIGHT

# Dictionaries
workout_config = {
    'adult': {
        'low': {
            'weight_loss':     {'exercises': 3, 'sets': 2, 'duration_per_exercise': 4},
            'stay_fit':        {'exercises': 3, 'sets': 2, 'duration_per_exercise': 4},
            'build_muscle':    {'exercises': 4, 'sets': 3, 'duration_per_exercise': 5},
            'gain_weight':     {'exercises': 4, 'sets': 3, 'duration_per_exercise': 5},
        },
        'moderate': {
            'weight_loss':     {'exercises': 4, 'sets': 3, 'duration_per_exercise': 5},
            'stay_fit':        {'exercises': 4, 'sets': 3, 'duration_per_exercise': 5},
            'build_muscle':    {'exercises': 5, 'sets': 4, 'duration_per_exercise': 6},
            'gain_weight':     {'exercises': 5, 'sets': 4, 'duration_per_exercise': 6},
        },
        'high': {
            'weight_loss':     {'exercises': 5, 'sets': 3, 'duration_per_exercise': 6},
            'stay_fit':        {'exercises': 5, 'sets': 3, 'duration_per_exercise': 6},
            'build_muscle':    {'exercises': 6, 'sets': 4, 'duration_per_exercise': 7},
            'gain_weight':     {'exercises': 6, 'sets': 4, 'duration_per_exercise': 7},
        }
    },
    'middle_aged': {
        'low': {
            'weight_loss':     {'exercises': 3, 'sets': 2, 'duration_per_exercise': 4},
            'stay_fit':        {'exercises': 3, 'sets': 2, 'duration_per_exercise': 4},
            'build_muscle':    {'exercises': 3, 'sets': 3, 'duration_per_exercise': 5},
            'gain_weight':     {'exercises': 3, 'sets': 3, 'duration_per_exercise': 5},
        },
        'moderate': {
            'weight_loss':     {'exercises': 4, 'sets': 2, 'duration_per_exercise': 5},
            'stay_fit':        {'exercises': 4, 'sets': 2, 'duration_per_exercise': 5},
            'build_muscle':    {'exercises': 4, 'sets': 3, 'duration_per_exercise': 6},
            'gain_weight':     {'exercises': 4, 'sets': 3, 'duration_per_exercise': 6},
        },
        'high': {
            'weight_loss':     {'exercises': 5, 'sets': 3, 'duration_per_exercise': 5},
            'stay_fit':        {'exercises': 5, 'sets': 3, 'duration_per_exercise': 5},
            'build_muscle':    {'exercises': 5, 'sets': 3, 'duration_per_exercise': 6},
            'gain_weight':     {'exercises': 5, 'sets': 3, 'duration_per_exercise': 6},
        }
    },
    'older_adult': {
        'low': {
            'weight_loss':     {'exercises': 2, 'sets': 2, 'duration_per_exercise': 3},
            'stay_fit':        {'exercises': 2, 'sets': 2, 'duration_per_exercise': 3},
            'build_muscle':    {'exercises': 2, 'sets': 2, 'duration_per_exercise': 4},
            'gain_weight':     {'exercises': 2, 'sets': 2, 'duration_per_exercise': 4},
        },
        'moderate': {
            'weight_loss':     {'exercises': 3, 'sets': 2, 'duration_per_exercise': 4},
            'stay_fit':        {'exercises': 3, 'sets': 2, 'duration_per_exercise': 4},
            'build_muscle':    {'exercises': 3, 'sets': 2, 'duration_per_exercise': 5},
            'gain_weight':     {'exercises': 3, 'sets': 2, 'duration_per_exercise': 5},
        },
        'high': {
            'weight_loss':     {'exercises': 4, 'sets': 2, 'duration_per_exercise': 4},
            'stay_fit':        {'exercises': 4, 'sets': 2, 'duration_per_exercise': 4},
            'build_muscle':    {'exercises': 4, 'sets': 3, 'duration_per_exercise': 5},
            'gain_weight':     {'exercises': 4, 'sets': 3, 'duration_per_exercise': 5},
        }
    }
}

# Reps per goal
goal_config = {
    'weight_loss': 15,
    'stay_fit': 15,
    'build_muscle': 10,
    'gain_weight': 8
}

# Seconds per rep based on age and activity
rep_time_config = {
    'adult':        {'low': 4, 'moderate': 4, 'high': 3},
    'middle_aged':  {'low': 5, 'moderate': 5, 'high': 4},
    'older_adult':  {'low': 6, 'moderate': 6, 'high': 5}
}

# Rest time between sets (in seconds)
rest_time_config = {
    'adult':        {'low': 45, 'moderate': 30, 'high': 20},
    'middle_aged':  {'low': 60, 'moderate': 45, 'high': 30},
    'older_adult':  {'low': 75, 'moderate': 60, 'high': 45}
}

# Calories calculator
def calculate_calories_burned(met, duration_minutes, weight_kg):
    return (met * 3.5 * weight_kg / 200) * duration_minutes

workouts_df = pd.read_csv("filtered_workouts.csv")
plan_df = pd.read_csv("weekly_plan_with_focus.csv")

# Focus Areas
focus_area_definitions = {
    'Upper Body Strength': {
        'target_muscles': ['Forearms', 'Shoulders', 'Biceps', 'Triceps', 'Chest'],
        'Type': ['Strength']
    },
    'Lower Body Strength': {
        'target_muscles': ['Hamstrings', 'Glutes', 'Quadriceps', 'Calves', 'Abductors', 'Adductors'],
        'Type': ['Strength']
    },
    'Core + Abs': {
        'target_muscles': ['Abdominals'],
        'Type': ['Strength', 'Core']
    },
    'Core + Chest': {
        'target_muscles': ['Abdominals', 'Chest'],
        'Type': ['Strength', 'Core']
    },
    'Light Endurance': {
        'target_muscles': ['Quadriceps', 'Calves', 'Glutes', 'Hamstrings'],
        'Type': ['Cardio', 'Mobility']
    },
    'Full Body Strength': {
        'target_muscles': ['Full Body', 'Biceps', 'Triceps', 'Shoulders', 'Glutes', 'Hamstrings'],
        'Type': ['Strength']
    },
    'Full Body HIIT': {
        'target_muscles': [],
        'Type': [],
        'Caution': ['HIIT', 'Plyometric HIIT', 'Isometric HIIT']
    },
    'Core + Lower Body': {
        'target_muscles': ['Abdominals','Hamstrings', 'Glutes', 'Quadriceps', 'Calves', 'Abductors', 'Adductors'],
        'Type': ['Strength', 'Core']
    },
    'Abs + Upper Body': {
        'target_muscles': ['Abdominals', 'Shoulders', 'Biceps', 'Triceps', 'Middle Back', 'Lower Back'],
        'Type': ['Strength']
    },
    'Cardio': {
        'target_muscles': [],
        'Type': ['Cardio']
    },
    'Active Rest Day': {
        'target_muscles': [],
        'Type': ['Mobility', 'Stretching']
    }
}

#Smart workouts with fallback strategies
def smart_get_workouts_for_focus(focus_area, activity_level):
    fallback_focus_map = {
        'Core + Lower Body Strength': ['Lower Body Strength', 'Core + Abs', 'Lower Body Strength'],
        'Full Body HIIT': ['Light Endurance', 'Cardio'],
        'Core + Chest': ['Core + Abs', 'Upper Body Strength'],
        'Abs + Upper Body': ['Core + Abs', 'Upper Body Strength'],
    }

    # Define light fallback: mobility/stretch
    default_light_fallback = workouts_df[
        (workouts_df['Type'].isin(['Mobility', 'Stretching'])) &
        (workouts_df['Difficulty'] == 'Beginner')
    ]

    def filter_workouts(focus):
        filters = focus_area_definitions.get(focus, {})
        if not filters:
            return []

        # Prepare filters
        muscle_filter = workouts_df['Target Muscle'].isin(filters.get('target_muscles', [])) if filters.get('target_muscles') else True
        type_filter = workouts_df['Type'].isin(filters.get('Type', [])) if filters.get('Type') else True
        caution_filter = workouts_df['Caution'].isin(filters.get('Caution', [])) if filters.get('Caution') else True

        # Apply combination
        if isinstance(muscle_filter, bool):
            filtered = workouts_df[type_filter & caution_filter]
        elif isinstance(type_filter, bool):
            filtered = workouts_df[muscle_filter & caution_filter]
        elif isinstance(caution_filter, bool):
            filtered = workouts_df[muscle_filter & type_filter]
        else:
            filtered = workouts_df[muscle_filter & type_filter & caution_filter]

        # Special case: Light Endurance Day
        if focus == 'Light Endurance':
            filtered = filtered[
                (filtered['Difficulty'].isin(['Beginner', 'Intermediate'])) &
                (filtered['MET Value'] <= 6)
            ]

        return filtered

    # Step 1: Try strict match
    primary_workouts = filter_workouts(focus_area)
    if not primary_workouts.empty:
        return primary_workouts.sort_values(by='MET Value').to_dict('records')

    # Step 2: Try fallback focus areas
    fallback_focuses = fallback_focus_map.get(focus_area, [])
    for alt_focus in fallback_focuses:
        fallback_workouts = filter_workouts(alt_focus)
        if not fallback_workouts.empty:
            return fallback_workouts.sort_values(by='MET Value').to_dict('records')

    # Step 3: Relax difficulty (e.g. include Intermediate for Beginners)
    if activity_level.lower() == 'low':
        relaxed = workouts_df[
            (workouts_df['Difficulty'].isin(['Beginner', 'Intermediate'])) &
            (workouts_df['MET Value'] <= 6)
        ]
        if not relaxed.empty:
            return relaxed.sort_values(by='MET Value').to_dict('records')

    # Step 4: Fallback to Mobility / Stretching
    if not default_light_fallback.empty:
        return default_light_fallback.sort_values(by='MET Value').to_dict('records')

    # Step 5: Nothing found
    return []


# Parameters
config = workout_config[age_group][activity_level][goal]
num_exercises = config['exercises']
sets = config['sets']
reps = goal_config[goal]
rep_time = rep_time_config[age_group][activity_level]  # seconds per rep
rest_time = rest_time_config[age_group][activity_level]  # seconds between sets

# Final Plan Creation
final_plan = []
focus_index_tracker = {}

for _, row in plan_df.iterrows():
    day_data = dict(row)
    focus = row['Focus']
    day_data['Workouts'] = []
    total_duration = 0
    total_calories = 0

    if 'Rest' in focus:
        if focus == 'Active Rest Day':
            # Populating with mobility and stretching exercises
            rest_exercises = workouts_df[
                workouts_df['Type'].isin(['Mobility', 'Stretching'])
            ].sample(n=3, replace=True).to_dict('records')

            for w in rest_exercises:
                duration_min = 0.5  # 30 secs per stretch
                calories = calculate_calories_burned(w.get('MET Value', 2.5), duration_min, weight)

                w['Sets'] = 1
                w['Reps'] = 'None'
                w['Rest Time (sec)'] = rest_time
                w['Duration (min)'] = duration_min
                w['Calories Burned'] = round(calories, 2)

                total_duration += duration_min
                total_calories += calories
                day_data['Workouts'].append(w)

            day_data['Total Duration (min)'] = round(total_duration, 2)
            day_data['Total Calories Burned'] = round(total_calories, 2)
        else:
            day_data['Total Duration (min)'] = 0
            day_data['Total Calories Burned'] = 0

    else:
        pool = smart_get_workouts_for_focus(focus, activity_level)
        start = focus_index_tracker.get(focus, 0)
        end = start + num_exercises
        selected = pool[start:end]

        if len(selected) < num_exercises:
            selected += pool[:num_exercises - len(selected)]
        focus_index_tracker[focus] = end % len(pool)

        for w in selected:
            met = w.get('MET Value', 3)

            # Check if this is an isometric hold exercise
            if 'Caution' in w and w['Caution'] == 'Isometric Hold':
                duration_min = 0.5
                exercise_sets = 1
                exercise_reps = 'None'
                exercise_rest_time = rest_time
                calories = calculate_calories_burned(met, duration_min, weight)
            else:
                # Regular exercise calculation
                total_seconds = (sets * goal_config[goal] * rep_time) + ((sets - 1) * rest_time)
                duration_min = total_seconds / 60
                exercise_sets = sets
                exercise_reps = goal_config[goal]
                exercise_rest_time = rest_time
                calories = calculate_calories_burned(met, duration_min, weight)

            w['Sets'] = exercise_sets
            w['Reps'] = exercise_reps
            w['Rest Time (sec)'] = exercise_rest_time
            w['Duration (min)'] = round(duration_min, 2)
            w['Calories Burned'] = round(calories, 2)

            total_duration += duration_min
            total_calories += calories
            day_data['Workouts'].append(w)

        day_data['Total Duration (min)'] = round(total_duration, 2)
        day_data['Total Calories Burned'] = round(total_calories, 2)

    final_plan.append(day_data)
with open("final_populated_workout_plan_with_reps_and_rest.json", "w") as f:
    json.dump(final_plan, f, indent=2)

print("Final plan with sets, reps, rest time, durations, and calories saved to 'final_populated_workout_plan.json'")